/// <reference types="pouchdb-find" />
/// <reference types="pouchdb-core" />
/// <reference types="pouchdb-mapreduce" />
/// <reference types="pouchdb-replication" />
import type { CollectionName, Collections, MutationInput, MutationPayload, MutableCollectionName, SavedInput } from "../../collections";
import * as Id from "../../id/index";
import type { Workspace, Historical } from "../../data";
/**
 * Aggegrates logic for interacting wth a set of PouchDB databases identified
 * by resource collection name.
 */
export declare abstract class Databases<C extends Collections> implements Workspace<C> {
    private collections;
    private definitions;
    private generateId;
    private ready;
    constructor(options: any);
    protected setup(_: any): void;
    protected abstract createDatabase(resource: CollectionName<C>): PouchDB.Database;
    private initialize;
    private initializeCollection;
    all<N extends CollectionName<C>>(collectionName: N): Promise<SavedInput<C, N>[]>;
    find<N extends CollectionName<C>>(collectionName: N, options: (Id.IdObject<C, N> | undefined)[] | PouchDB.Find.FindRequest<{}>): Promise<(SavedInput<C, N> | undefined)[]>;
    get<N extends CollectionName<C>>(collectionName: N, id: string | undefined): Promise<Historical<SavedInput<C, N>> | undefined>;
    add<N extends CollectionName<C>>(collectionName: N, input: MutationInput<C, N>): Promise<MutationPayload<C, N>>;
    update<M extends MutableCollectionName<C>>(collectionName: M, input: MutationInput<C, M>): Promise<MutationPayload<C, M>>;
    remove<M extends MutableCollectionName<C>>(collectionName: M, input: MutationInput<C, M>): Promise<void>;
}
